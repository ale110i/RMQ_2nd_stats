//
//  main.cpp
//  RMQ_2nd_stats
//
//  Created by Alexey Ischenko on 03.10.2019.
//  Copyright © 2019 Enthropy. All rights reserved.
//

#include <iostream>
#include <vector>
#include <stdint.h>
#include <cmath>

//Ае, с вами Превеликий Пояснитель. Нет, не от слова поясница.
//Сегодня мы пройдём получение второй статистики при помощи RMQ и SparseTable

//SparseTable — разреженная таблица. Это такая няшка, которая содержит в себе
//минимумы всех отрезков длиной в степень двойки. Но в нашем случае будет содержать
//ещё и вторую статистику.

using namespace std;

//Для этого нам, очевидно, потребуется какая-нибудь структурка.
//Как бы назвать структурку, которая хранит отрезок?

//Есть идеи?

//Всё гениальное просто. Назовём её самым банальным и лаконичным образом.
//Представляю вашему вниманию:

class Segment{ //Отрезок. Совершенно новый и магически простой iОтрезок от Apple
public:
    int_fast32_t first_min; //Он хранит минимум!
    int_fast32_t second_min; //Он хранит какую-то хрень, которая чуть больше минимума!
    int_fast32_t fm_position; //Он хранит позицию минимума!
    int_fast32_t sm_position; //И, хоть вы и не просили, но даже позицию этой хрени!
    Segment() = delete; //А ещё его нельзя просто так создать.
    Segment(int_fast32_t f, int_fast32_t s, int_fast32_t fp, int_fast32_t sp);
    //Это может сделать только Apple. И только с четырёх рук. Аргументов, простите*
};

Segment::Segment(int_fast32_t f, int_fast32_t s, int_fast32_t fp, int_fast32_t sp){
    first_min = f;
    second_min = s;
    fm_position = fp;
    sm_position = sp;
    //Да, всё гениальное просто
}

//Ну, с отрезком разобрались. Теперь нам нужна табличка.

//Полагаю, одноимённый класс будет хорошим решением.

class SparseTable{ //Да, это именно то, о чём вы подумали
private:
    vector<vector<Segment*>> table; //Сама таблица, размера n*log(n)
    vector<int_fast32_t> base_array; //Тот массив, который мы обрабатываем
    vector<int_fast32_t> logs_array; //Логарифмы. Просто допустим, что они нужны.
    uint_fast64_t base_len; //Просто длина массива. Мы же не хотим тревожить .size()?
public:
    SparseTable(vector<int_fast32_t> &base); //Конструктор. Уникальный. Запатентовванный.
    void pre_process(); //Самая скромная, но самая полезная функция. Прямо как я. Нет.
    int_fast32_t ans_gainer(const int_fast32_t &left, const int_fast32_t &right); //См. вниз
    //Да, сюда смотри. Она отвечает за свои слова. И за отрезки тоже, хотя они не просили.
    //Она выдаёт второе по минимальности значение для отрезка, заданного своими координатами.
    //Координаты идут от 1 и до длины массива, включаются оба конца отрезка, это ж отрезок.
};

SparseTable::SparseTable(vector<int_fast32_t> &base){ //О, да, передача по ссылке. Я кончил.
    base_array = base; //И тут же присваивание копированием. Корпоративная тайна, если что.
    base_len = base_array.size(); //Не тревожить .size()? Забудьте. Не в этот раз.
    table.resize(0); //Ну, а хули? А вдруг там мусор в пустом массиве погреться решил?
    logs_array.resize(0); //Ну и тебя тоже, на всякий случай. Но пока карандашом.
}

void SparseTable::pre_process(){ //Да, это я, няшка-скромняшка-полезняшка :3
    vector<Segment*> layer; //Короче, это слой. Тупо слой.
    //Ну, мы же долго будем заполнять вектор векторов указателей. Так что он нужен.
    layer.resize(base_len); //Ну... Первый слой всегда совпадает с исходным массивом. Just because.
    logs_array.resize(base_len + 1); //О, принёс дз? Ладно, хорошо. Не неуд(0). Хор(base_len + 1)!
    logs_array[0] = 0; //Оно всё равно не понадобится, чего бы и не занулить.
    //Зачем есть капусту, когда есть картошка. Тут так же. Зачем не обнулять, если можно обнулить.
    for (int_fast32_t i = 0; i < base_len; ++i){ //Короче, мы считаем первый слой и няшку.
        layer[i] = new Segment(base_array[i], base_array[i], i, i); //Просто копируем с поправкой.
        //Поправкой на то, что у нас массив указателей на структуру Отрезок. iОтрезок.
        logs_array[i + 1] = log2(i + 1); //Заодно посчитаем полезную прелесть.
        //А то асимптотику испортит.
    }
    //Ну, самое простое позади. Да начнётся жесть!
    table.push_back(layer); //Закидываем первый слой.
    layer.clear(); //Очищаем, чтобы случайно не страдать хернёй
    layer.resize(base_len - 1); //Ну... Отрезков длиной 2 ровно на 1 меньше, чем длина массива.
    //Почему? Ну, отрезок [1, 2], [2, 3], и так далее. Их base_len - 1 штук.
    for (int_fast32_t i = 0; i < base_len - 1; ++i){ //Бежим и заполняем.
        if (base_array[i] < base_array[i + 1]){ //В отрезке два элемента, можно сравнить в лоб.
            layer[i] = new Segment(base_array[i], base_array[i + 1], i, i + 1); //Вариант #1
        }
        else {
            layer[i] = new Segment(base_array[i + 1], base_array[i], i + 1, i); //Вариант #2
        }
        //В принципе, тут пока что всё просто и понятно. У нас есть полноформатные отрезки.
        //Дальше уже будем работать с ними. Но для начала...
    }
    table.push_back(layer); //Закидываемся слоем чего-нибудь, а этот слой закидываем в таблицу.
    layer.clear(); //И очищаем его. Всегда мойте руки, перед и слой. Не спрашивайте. Мойте.
    for (int_fast32_t k = 2; base_array.size() > pow(2, k); ++k){ //Нам нужно заполнить таблицу.
        //Примерно до высоты log(n). Ну, просто дальше у нас длины отрезков будут такими большими,
        //что превзойдут оригинальный массив
        layer.clear(); //Тщательно мойте!! С мылом!
        layer.resize(base_array.size() - pow(2, k) + 1); //А это у нас длина каждого слоя.
        //Коэффициенты вообще очевидны, но так-то просто вычитаем длину отрезка без единички.
        for (int_fast32_t i = 0; i < layer.size(); ++i){ //А ещё заполняем превеликий слой.
            //Знаете, а мне нравится этот парень. Он такой мощный. Теперь это iСлой. By Innovations Only.
            Segment* i_th_element = new Segment(0, 0, 0, 0); //Пустой конструктор? Слишком просто.
            if (table[k - 1][i]->first_min < table[k - 1][i + pow(2, k - 1)]->first_min){
                //Здесь важное уточнение. У нас в каждом отрезке есть минимум, а есть минимум_чуть_побольше.
                //Вполне тривиально, что минимумом на их объединении, который мы в общем-то и получаем здесь,
                //будет их общий минимум. Но. Их второй статистикой будет либо минимум другого отрезка, либо
                //минимум_чуть_побольше из того отрезка, из которого мы выдернули основной минимум.
                i_th_element->first_min = table[k - 1][i]->first_min; //Так что кидаем общий минимум
                i_th_element->fm_position = table[k - 1][i]->fm_position; //Кидаем его позицию
                //Потом объясню, зачем она вообще нужна
                i_th_element->second_min = min(table[k - 1][i]->second_min, table[k - 1][i + pow(2, k - 1)]->first_min);
                //Кидаем то, что будет общим минимумом_чуть_побольше
                i_th_element->sm_position = table[k - 1][i]->second_min < table[k - 1][i + pow(2, k - 1)]->first_min? table[k - 1][i]->sm_position : table[k - 1][i + pow(2, k - 1)]->fm_position;
                //И закидываем позицию минимума_чуть_побольше, которая нам абсолютно не нужна.
                //А ещё она почему-то некорректно считается и иногда лагает. Но я вам этого не говорил.
            }
            else {
                //Аналогично для случая, когда общим минимумом будет минимум второго отрезка
                i_th_element->first_min = table[k - 1][i + pow(2, k - 1)]->first_min;
                i_th_element->fm_position = table[k - 1][i + pow(2, k - 1)]->fm_position;
                i_th_element->second_min = min(table[k - 1][i]->first_min, table[k - 1][i + pow(2, k - 1)]->second_min);
                i_th_element->sm_position = table[k - 1][i]->first_min < table[k - 1][i + pow(2, k - 1)]->second_min ? table[k - 1][i]->fm_position : table[k - 1][i + pow(2, k - 1)]->sm_position;
                //Видимо, возник вопрос, где здесь объединение. Ну... Отрезок table[k + 1][i] в два раза
                //больше отрезка table[k][i] и начинается с последнего. А ещё содержит вторую половинку себя.
                //Эта вторая половинка себя — table[k][i + 2^k], ибо длина обеих половинок 2^k.
                //Почему у половинок такая длина? Видимо, я что-то пропустил в начале.
                //SparseTable имеет размеры [0..log(n)][n], хоть и каждый последующий слой меньше предыдущего.
                //Просто потому, что на позиции table[k][i] находится информация об отрезке... Простите.
                //Об iОтрезке [i..i + 2^k]. Это удобно и практично. Потом увидите, почему.
            }
            layer[i] = i_th_element; //Собственно, заполняем нашу няшку. iSlow! iСлой, то есть.
        }
        table.push_back(layer); //Ну и добавляем в таблицу.
        //Всё, думали к следующей функции перейти? А слой помыть?
        //Шутка, это был цикл. Но впредь не забывайте.
    }
}

//Как и в любой задаче, должно быть нечто, что выдаст конечный ответ. У нас это делает функция...
//Ответ_гей... Ответ_гей... Ответо_получатель! Вот ты люлей от мамки получаешь, а он ответы. Причём правильные.
//Учись у него. Будь как ответ_гей... Ладно, просто функция. На этом остановимся.

int_fast32_t SparseTable::ans_gainer(const int_fast32_t &left, const int_fast32_t &right){
    //Ответ_гей(...) принимает в себя целых два числа. Таких больших, солидных и константных.
    //Чтобы не запутаться, какое число — чьё, скажем, что первый вошёл слева, а второй — справа.
    int_fast32_t k = logs_array[right - left + 1]; //Не ожидали? Наш ответ... функция. Наш функция — скорострел.
    //Мало того, всегда работает за одно и то же константное время O(1).
    //Никто не засекал, но, говорят, очень быстро. А заранее подсчитанный k ему в этом помогает.
    int_fast32_t answer = 0; //Поскольку функция получает ответ, он должен иметь в себе ответ.
    //Тот самый ответ, которым он конч... Окончит свою работу, выкинув наружу мощной... Числом.
    
    //Тут важная ремарка. Важная. ЧИТАТЬ ВСЕМ, УБЕРВАЖНО! Ха, как легко вас развести.
    
    //А тут действительно нужная вещь. Отрезок на входе не обязательно имеет степень двойки в качестве длины.
    //Поэтому, мы можем его представить, как объединение (не сложение) двух отрезков, кратных по длине 2^k.
    Segment* fs = table[k][left]; //Соответственно, левый (от left до left + 2^k)
    Segment* ss = table[k][right - pow(2, k) + 1]; //И правый (от right - 2^k до right)
    //Да, я тоже оценил то, насколько наш функция педант. Оба отрезка одинаковой длины.
    //Но с некоторой долей вероятности мы можем попасть в ситуацию, когда наш отрезок состоит из двух элементов.
    //Тогда мы просто выведем тот, что побольше. Все же любят побольше. Ответ_гей... Функция тоже, в общем.
    if (k == 0){ //логарифм равен нулю при длине отрезка, равной 1. То есть разнице конца и начала.
        //В общем, вот так. Оно работает. Не трогайте его.
        return max(table[0][left]->first_min, table[0][right]->first_min); //Как и обещалось.
        //Раньше времени он ответ наружу не выдаст, нужно постараться.
    }
    //Поскольку кусочки отрезка могут пересекаться, на отрезках может быть один и тот же минимум.
    //Или два таких же, одинаковых, но на разных позициях. Поэтому сравниваем позиции, а не элементы.
    //Позиции заблаговременно были сохранены в индексах по основному вектору, так что проблем не возникнет.
    if (fs->fm_position != ss->fm_position){ //Если позиции различаются, то придётся думать.
        if (fs->first_min < ss->first_min){ //Если первый минимум меньше второго, то... Хм.
            answer = min(fs->second_min, ss->first_min);
            //Ответом будет то, что лишь немного больше него. Либо второй минимум, либо тот самый, грандиозный.
            //Минимум_чуть_побольше из первого подотрезка.
        }
        else {
            answer = min(fs->first_min, ss->second_min); //Аналогично для оборотной ситуации.
        }
    }
    else {
        answer = min(fs->second_min, ss->second_min); //Если позиции минимумов совпали, то всё проще.
        //У отрезков банально один и тот же минимум. А значит, их минимумом_чуть_побольше будет...
        //Тот минимум_чуть_побольше из них двоих, который чуть-чутее больше, чем другой.
        //Короче, минимальная из вторых статистик этих подотрезков.
    }
    return answer; //Кончили.
}

//Ну и куда же без int main()?

int main() {
    vector<int_fast32_t> array;
    int_fast32_t n;
    int_fast64_t m;
    int_fast32_t left, right;
    cin >> n >> m;
    array.resize(n);
    for (int_fast32_t i = 0; i < n; ++i){
        cin >> array[i];
    }
    SparseTable sparse_table = SparseTable(array);
    sparse_table.pre_process();
    for (int_fast32_t i = 0; i < m; ++i){
        cin >> left >> right;
        --left;
        --right;
        cout << sparse_table.ans_gainer(left, right) << "\n";
    }
    return 0;
}

//Простите, что без шуточек тут. Я пошёл кушать. Всем спасибо за внимание!
